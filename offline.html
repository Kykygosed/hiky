<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hors connexion — Kyky</title>
  <meta name="theme-color" content="#6d28d9">
  <style>
    :root{
      --bg: linear-gradient(180deg,#f8fafc,#eef2ff);
      --card:#fff;
      --muted:#6b7280;
      --accent:#6d28d9;
      --glass: rgba(255,255,255,0.7);
    }
    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,'Segoe UI',Roboto,'Helvetica Neue',Arial; margin:0;padding:0}
    html,body{height:100%}
    body{
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background:var(--bg);
      padding:24px;
      color:#0f172a;
    }

    .container{
      width:100%;
      max-width:820px;
      text-align:center;
      background:linear-gradient(180deg, rgba(255,255,255,0.8), rgba(255,255,255,0.78));
      border-radius:16px;
      padding:28px;
      box-shadow: 0 18px 40px rgba(15,23,42,0.08);
      display:flex;
      flex-direction:column;
      gap:18px;
      align-items:center;
    }

    h1{
      font-size:18px;
      color:var(--muted);
      margin-top:6px;
    }

    .game-wrap{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
      width:100%;
    }

    /* Canvas area */
    .stage{
      background: linear-gradient(180deg,#f3f4f6 0%, #ffffff 60%);
      border-radius:10px;
      padding:12px;
      box-shadow: inset 0 -6px 18px rgba(2,6,23,0.02);
      display:flex;
      align-items:center;
      justify-content:center;
    }

    canvas{
      background: linear-gradient(180deg,#ffffff,#f8fafc);
      border-radius:6px;
      width:100%;
      max-width:720px;
      height:120px;
      display:block;
    }

    .info{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:center;
      flex-wrap:wrap;
      margin-top:6px;
    }

    .score-box{
      background: rgba(13,17,23,0.04);
      padding:8px 12px;
      border-radius:8px;
      font-weight:600;
    }
    .highscore{font-size:13px;color:var(--muted)}

    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:center;
      margin-top:6px;
    }

    .btn{
      padding:8px 12px;
      border-radius:10px;
      border:none;
      cursor:pointer;
      font-weight:600;
      background:linear-gradient(90deg,var(--accent),#7c3aed);
      color:white;
      box-shadow: 0 8px 20px rgba(109,40,217,0.12);
    }
    .btn.ghost{
      background:transparent;color:var(--accent);border:1px solid rgba(109,40,217,0.12);box-shadow:none;
    }

    .offline-msg{
      margin-top:6px;
      font-size:20px;
      font-weight:700;
      color:#0f172a;
    }

    .sub{
      font-size:13px;color:var(--muted);
    }

    footer{font-size:12px;color:var(--muted);margin-top:8px}

    /* touch hint */
    .touch-hint{
      display:none;
      font-size:13px;color:var(--muted);
    }
    @media (max-width:640px){
      canvas{height:110px}
      .touch-hint{display:block}
    }
  </style>
</head>
<body>
  <main class="container" role="main" aria-labelledby="offlineTitle">
    <div class="game-wrap" role="region" aria-label="Jeu hors connexion">
      <div class="stage" aria-hidden="false">
        <canvas id="dinoCanvas" width="720" height="120" aria-label="Jeu Dino"></canvas>
      </div>

      <div class="info" aria-hidden="false">
        <div class="score-box">Score : <span id="score">0</span></div>
        <div class="score-box highscore">Meilleur : <span id="best">0</span></div>
      </div>

      <div class="controls" aria-hidden="false">
        <button id="btnJump" class="btn ghost" title="Sauter (Espace / Ecran)">Sauter</button>
        <button id="btnRestart" class="btn" title="Rejouer">Rejouer</button>
      </div>

      <div class="offline-msg" id="offlineTitle">Vous êtes hors connexion</div>
      <div class="sub">Le score est sauvegardé localement dans l’application.</div>
      <div class="touch-hint">Astuce mobile : tape sur le bouton "Sauter" ou l'écran pour sauter.</div>
    </div>

    <footer>App Kyky — Mini jeu hors ligne</footer>
  </main>

  <script>
    /*
      Mini Chrome Dino-like game
      - Drawn with canvas (no images)
      - Score increments over time
      - Highscore persisted in localStorage key 'kyky_dino_highscore'
      - Controls: Space / ArrowUp / Click / Touch / "Sauter" button
    */

    (function(){
      const canvas = document.getElementById('dinoCanvas');
      const ctx = canvas.getContext('2d');

      // Logical size for consistent rendering
      const W = canvas.width;
      const H = canvas.height;

      // UI elements
      const scoreEl = document.getElementById('score');
      const bestEl = document.getElementById('best');
      const btnJump = document.getElementById('btnJump');
      const btnRestart = document.getElementById('btnRestart');

      // Storage key
      const HS_KEY = 'kyky_dino_highscore';

      // Game variables
      let running = false;
      let gameOver = false;
      let score = 0;
      let best = parseInt(localStorage.getItem(HS_KEY) || '0', 10) || 0;
      bestEl.textContent = best;

      // Dino properties
      const dino = {
        x: 80,
        y: H - 28 - 12, // ground y (dino feet)
        w: 28,
        h: 28,
        vy: 0,
        gravity: 0.9,
        jumpForce: -14,
        grounded: true,
        ducking: false
      };

      // Ground
      const ground = {
        y: H - 12
      };

      // Obstacles
      let obstacles = [];
      let spawnTimer = 0;
      let spawnInterval = 90; // frames

      // Speed
      let speed = 6;
      let frame = 0;

      // For smooth time-based scoring
      let lastTime = performance.now();

      // Start the game
      function startGame(){
        running = true;
        gameOver = false;
        score = 0;
        speed = 6;
        obstacles = [];
        spawnTimer = 0;
        frame = 0;
        dino.y = H - 28 - 12;
        dino.vy = 0;
        dino.grounded = true;
        lastTime = performance.now();
        loop();
      }

      // End game
      function endGame(){
        running = false;
        gameOver = true;
        // Save highscore
        if(score > best){
          best = Math.floor(score);
          localStorage.setItem(HS_KEY, String(best));
          bestEl.textContent = best;
        }
        // simple flash or text (we keep it simple)
      }

      // Spawn obstacle
      function spawnObstacle(){
        const types = ['small','big'];
        const t = types[Math.floor(Math.random()*types.length)];
        if(t === 'small'){
          obstacles.push({
            x: W + 30,
            w: 12,
            h: 20,
            y: ground.y - 20
          });
        } else {
          obstacles.push({
            x: W + 30,
            w: 20,
            h: 32,
            y: ground.y - 32
          });
        }
      }

      // Input: jump
      function doJump(){
        if(!running){
          startGame();
          return;
        }
        if(!dino.grounded) return;
        dino.vy = dino.jumpForce;
        dino.grounded = false;
      }

      // Input handlers
      document.addEventListener('keydown', (e)=>{
        if(e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW'){
          e.preventDefault();
          doJump();
        }
        if(e.code === 'KeyR' && gameOver){
          startGame();
        }
      });

      // Click / touch to jump
      canvas.addEventListener('click', doJump);
      canvas.addEventListener('touchstart', (e)=>{
        e.preventDefault();
        doJump();
      }, {passive:false});

      btnJump.addEventListener('click', doJump);
      btnRestart.addEventListener('click', ()=> {
        startGame();
        canvas.focus();
      });

      // Collision detection AABB
      function collides(a, b){
        return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
      }

      // Draw functions
      function drawBackground(){
        // sky gradient already via CSS; draw ground line and repeating simple mountains
        // draw ground
        ctx.fillStyle = '#f8fafc';
        ctx.fillRect(0, 0, W, H);

        // Ground strip
        ctx.fillStyle = '#e6e7ea';
        ctx.fillRect(0, ground.y, W, H - ground.y);

        // decorative moving lines (parallax)
        ctx.fillStyle = 'rgba(16,24,40,0.03)';
        for(let i=0;i<8;i++){
          const px = (frame* (0.5 + i*0.08) * speed) % (W + 200) - 100;
          ctx.fillRect(px - i*6, ground.y - 6 - i*8, 160, 2);
        }
      }

      function drawDino(){
        // body
        ctx.save();
        ctx.translate(dino.x, dino.y);
        // shadow
        ctx.fillStyle = 'rgba(15,23,42,0.06)';
        ctx.fillRect(-2, dino.h + 2, dino.w + 8, 6);

        // body rectangle
        ctx.fillStyle = '#111827';
        ctx.fillRect(0, 0, dino.w, dino.h);

        // eye (simple)
        ctx.fillStyle = '#fff';
        ctx.fillRect(dino.w - 10, 6, 6, 6);
        ctx.fillStyle = '#111827';
        ctx.fillRect(dino.w - 8, 8, 2, 2);

        // tail
        ctx.fillStyle = '#111827';
        ctx.fillRect(-6, 6, 6, 6);

        ctx.restore();
      }

      function drawObstacle(ob){
        ctx.fillStyle = '#111827';
        ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
      }

      function drawScore(){
        // score drawn via DOM; we can add subtle HUD
      }

      // Main loop
      function loop(ts){
        if(!running) {
          render(); // still render the scene so user sees static dino
          return;
        }
        const now = performance.now();
        const dt = Math.min(40, now - lastTime); // cap dt
        lastTime = now;

        // update physics
        // dino gravity
        dino.vy += dino.gravity * (dt/16);
        dino.y += dino.vy * (dt/16);

        // ground collision
        if(dino.y >= H - dino.h - 12){
          dino.y = H - dino.h - 12;
          dino.vy = 0;
          dino.grounded = true;
        }

        // obstacles movement
        for(let i = obstacles.length -1; i>=0; i--){
          obstacles[i].x -= speed * (dt/16);
          // remove offscreen
          if(obstacles[i].x + obstacles[i].w < -20){
            obstacles.splice(i,1);
          }
        }

        // spawn
        spawnTimer++;
        if(spawnTimer > spawnInterval){
          spawnObstacle();
          spawnTimer = 0;
          // slightly randomize spawn interval and increase difficulty
          spawnInterval = 70 + Math.floor(Math.random()*60);
        }

        // collision detection
        for(let ob of obstacles){
          const dbox = {x: dino.x, y: dino.y, w: dino.w, h: dino.h};
          const obox = {x: ob.x, y: ob.y, w: ob.w, h: ob.h};
          if(collides(dbox, obox)){
            endGame();
            break;
          }
        }

        // score increment by time
        score += (dt/16) * 0.2; // smooth increment
        frame++;
        // increase speed over time
        if(frame % 300 === 0) speed += 0.4;

        // render
        render();

        // update DOM score
        scoreEl.textContent = Math.floor(score);
        lastTime = now;

        if(running) requestAnimationFrame(loop);
      }

      function render(){
        // clear
        ctx.clearRect(0,0,W,H);

        drawBackground();

        // draw obstacles
        for(let ob of obstacles){
          drawObstacle(ob);
        }

        // draw dino
        drawDino();

        // if game over, show overlay
        if(gameOver){
          ctx.fillStyle = 'rgba(255,255,255,0.7)';
          ctx.fillRect(W/2 - 160, H/2 - 28, 320, 56);
          ctx.fillStyle = '#0f172a';
          ctx.font = '600 16px Inter, system-ui, -apple-system, "Segoe UI", Roboto';
          ctx.textAlign = 'center';
          ctx.fillText('Game Over — Appuie sur Rejouer', W/2, H/2 + 6);
        }

        // draw subtle HUD (best)
        ctx.fillStyle = '#0f172a';
        ctx.font = '600 14px Inter, system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('Score: ' + Math.floor(score), 10, 18);
        ctx.textAlign = 'right';
        ctx.fillText('Best: ' + best, W - 10, 18);
      }

      // initial render (idle dino)
      render();

      // show best in DOM
      bestEl.textContent = best;

      // Auto start when user interacts, or start on pressing jump
      // We keep it conservative: start only when user presses jump / click / restart
      // But we can offer to auto-start on load (uncomment if desired)
      // startGame();

      // If page is visible again, resume animation frame if running
      document.addEventListener('visibilitychange', ()=>{
        if(!document.hidden && running){
          lastTime = performance.now();
          requestAnimationFrame(loop);
        }
      });

      // Save best when unloading just in case
      window.addEventListener('beforeunload', ()=> {
        if(score > best){
          localStorage.setItem(HS_KEY, String(Math.floor(score)));
        }
      });

      // Expose startGame to allow auto start from UI
      window.kykyOffline = { startGame };

      // Optional: start automatically after small intro delay to show interactivity
      setTimeout(()=> {
        // try to auto-start for better UX on large screens
        if(window.innerWidth > 480) {
          // start only if user has previously played or wants auto-start
          // startGame();
        }
      }, 800);
    })();
  </script>
</body>
</html>
